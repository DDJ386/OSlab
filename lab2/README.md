- [2.1 进程的软中断通信](#21-进程的软中断通信)
  - [实验思路:](#实验思路)
  - [遇到的问题及解决方案:](#遇到的问题及解决方案)
- [2.2 进程的管道通信](#22-进程的管道通信)
  - [实验思路:](#实验思路-1)
  - [实验结果记录:](#实验结果记录)
- [2.3 内存的分配与回收](#23-内存的分配与回收)

# 2.1 进程的软中断通信
## 实验思路:
在父进程中调用signal()改变父进程对三个信号的操作:SIGINT, SIGQUIT, SIGALRM, 让他们做出相同的操作--向两个子进程分别发送结束信号, 但由于他们分别输出不同的log信息, 因此将他们分在不同处理函数中. 接着调用pause()挂起进程等待信号.  
在子进程中调用signal()改变他们对相应信号的操作, 然后调用pause()挂起进程并等待信号的来临.  
在调试过程中, 发现当键盘输入SIGINT和SIGQUIT时会导致两个子进程收到信号后直接结束,导致结果与预期不符, 并且无法保证子进程接收到信号时已经完成了调用signal()的准备工作, 因此采取阻塞信号的方式, 将SIGINT, SIGQUIT, SIGCHILD, SIGSTKFLT四个信号阻塞, 当完成signal()准备工作后, 解除对SIGCHILD和SIGSTKFLT两个信号的阻塞以能够接收到父进程发来的信号. 经过这样的调整后输出结果符合预期.  
## 遇到的问题及解决方案:
- 如何阻塞信号  
解决方案: 在CSAPP一书第8.5节找到关于信号阻塞的相关知识.  
- 关于signal(), alarm()等函数的使用  
解决方案: 阅读man page解决  

# 2.2 进程的管道通信
## 实验思路:  
简单按照注释补全代码  
## 实验结果记录:  
在有锁的情况下:  
![Result with lock](./image1.png)
在没锁的情况下:  
![Result without lock](./image2.png)

# 2.3 内存的分配与回收

